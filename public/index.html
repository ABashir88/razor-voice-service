<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Visual Cortex</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@200;300;400;600;800&display=swap');
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#000;overflow:hidden;font-family:'Outfit',sans-serif;display:flex;align-items:center;justify-content:center;width:100vw;height:100vh}
  canvas{position:fixed;top:0;left:0}

  #stateLabel{position:fixed;bottom:60px;width:100%;text-align:center;font-size:28px;font-weight:300;letter-spacing:14px;z-index:10;pointer-events:none;transition:color 1.2s, text-shadow 1.2s;text-shadow:0 0 30px currentColor,0 0 60px currentColor}

  #transcript{position:fixed;bottom:120px;width:100%;text-align:center;z-index:10;pointer-events:none;opacity:0;transition:opacity 0.5s}
  #transcript.show{opacity:1}
  .tx-who{font-size:9px;font-weight:700;letter-spacing:5px;text-transform:uppercase;margin-bottom:5px}
  .tx-text{font-size:16px;font-weight:200;line-height:1.7;color:rgba(255,255,255,0.6);max-width:540px;margin:0 auto;padding:0 20px}
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="stateLabel">IDLE</div>
<div id="transcript"><div class="tx-who" id="txWho"></div><div class="tx-text" id="txText"></div></div>

<script>
// ═══════════════════════════════════════════════════════════════
//  SPHERE — Canvas 2D Flowing Wave Visualization
//  Layered luminous waves with additive blending
// ═══════════════════════════════════════════════════════════════

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let W, H, CX, CY, R;

function resize() {
  const dpr = Math.min(devicePixelRatio, 2);
  W = innerWidth * dpr;
  H = innerHeight * dpr;
  canvas.width = W;
  canvas.height = H;
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  CX = W / 2;
  CY = H / 2;
  R = Math.min(W, H) * 0.28;
}
resize();
addEventListener('resize', resize);

// ═══════════════════════════════════════════════════════
//  STATE CONFIG — Vivid, captivating, god-like palette
// ═══════════════════════════════════════════════════════

const STATES = {
  idle: {
    // Electric Blue — omniscient presence, calm intelligence
    coreColor: [0, 120, 255],
    waveColors: [
      [0, 140, 255, 0.7],
      [30, 170, 255, 0.6],
      [80, 200, 255, 0.5],
      [140, 220, 255, 0.35],
    ],
    glowColor: [0, 100, 255],
    waveAmp: 0.04,
    waveSpeed: 0.5,
    spikeAmp: 0,
    rotSpeed: 0.08,
    coreGlow: 0.7,
    bloomSize: 1.6,
    particleColor: [100, 180, 255],
    breathe: 0.015,
    ringCount: 0,
  },
  listening: {
    // Bright Emerald — engaged, absorbing, attentive
    coreColor: [0, 255, 140],
    waveColors: [
      [0, 255, 160, 0.75],
      [40, 255, 190, 0.65],
      [80, 255, 210, 0.55],
      [140, 255, 230, 0.4],
    ],
    glowColor: [0, 240, 130],
    waveAmp: 0.14,
    waveSpeed: 0.9,
    spikeAmp: 0.18,
    rotSpeed: 0.22,
    coreGlow: 0.8,
    bloomSize: 1.8,
    particleColor: [0, 255, 180],
    breathe: 0.04,
    ringCount: 0,
  },
  processing: {
    // Vivid Purple — deep computation, cosmic intelligence
    coreColor: [180, 0, 255],
    waveColors: [
      [190, 40, 255, 0.75],
      [210, 90, 255, 0.65],
      [230, 140, 255, 0.5],
      [245, 180, 255, 0.35],
    ],
    glowColor: [160, 0, 250],
    waveAmp: 0.1,
    waveSpeed: 1.8,
    spikeAmp: 0.12,
    rotSpeed: 0.7,
    coreGlow: 0.85,
    bloomSize: 1.9,
    particleColor: [210, 120, 255],
    breathe: 0,
    ringCount: 3,
  },
  speaking: {
    // Bright Gold — authority, revelation, wisdom
    coreColor: [255, 185, 0],
    waveColors: [
      [255, 200, 40, 0.8],
      [255, 220, 90, 0.7],
      [255, 235, 140, 0.55],
      [255, 245, 180, 0.4],
      [255, 252, 220, 0.25],
    ],
    glowColor: [255, 170, 0],
    waveAmp: 0.25,
    waveSpeed: 1.1,
    spikeAmp: 0.4,
    rotSpeed: 0.16,
    coreGlow: 0.95,
    bloomSize: 2.0,
    particleColor: [255, 210, 60],
    breathe: 0,
    ringCount: 0,
  },
};

let state = 'idle';
let energy = 0, energyTarget = 0;
let t = 0;

// Smoothed current values
let cur = {
  core: [0, 120, 255],
  glow: [0, 100, 255],
  waveAmp: 0.04,
  waveSpeed: 0.5,
  spikeAmp: 0,
  rotSpeed: 0.08,
  coreGlow: 0.7,
  bloomSize: 1.6,
  pc: [100, 180, 255],
  breathe: 0.015,
  ringCount: 0,
};

function lerp(a, b, t) { return a + (b - a) * t; }
function lerpA(a, b, t) { return a.map((v, i) => lerp(v, b[i], t)); }

function synthEnergy(t) {
  return 0.05 + Math.sin(t*6.28)*0.035 + Math.sin(t*14.8)*0.02
    + Math.sin(t*30.5)*0.01 + Math.random()*0.005;
}

// ═══════════════════════════════════════════════════════
//  WAVE LAYER CLASS — more harmonics, wider lines
// ═══════════════════════════════════════════════════════

class WaveLayer {
  constructor(index, total) {
    this.index = index;
    this.total = total;
    this.yOffset = (index / total - 0.5) * 2;
    this.freq = 2 + index * 1.1 + Math.random() * 0.6;
    this.phase = Math.random() * Math.PI * 2;
    this.speed = 0.7 + Math.random() * 0.7;
    this.thickness = 1.8 + Math.random() * 1.8;
  }

  draw(ctx, time, cx, cy, radius, amp, spikeAmp, color, alpha, speedMult) {
    const lat = this.yOffset * 0.85;
    const sliceRadius = radius * Math.cos(lat * Math.PI / 2);
    const sliceY = cy + lat * radius * 0.9;

    if (sliceRadius < 5) return;

    const totalAmp = amp + energy * 0.6 + spikeAmp * energy * 2.5;

    ctx.beginPath();
    const steps = 220;
    for (let i = 0; i <= steps; i++) {
      const pct = i / steps;
      const angle = pct * Math.PI * 2;

      const wave1 = Math.sin(angle * this.freq + time * this.speed * speedMult + this.phase) * totalAmp;
      const wave2 = Math.sin(angle * (this.freq * 1.7) - time * this.speed * speedMult * 1.3 + this.phase * 2) * totalAmp * 0.45;
      const wave3 = Math.sin(angle * (this.freq * 3.1) + time * this.speed * speedMult * 2 + this.phase * 0.7) * totalAmp * 0.2;
      const wave4 = Math.sin(angle * (this.freq * 5.3) - time * this.speed * speedMult * 3.1 + this.phase * 1.3) * totalAmp * 0.08;

      const wave = (wave1 + wave2 + wave3 + wave4) * radius;

      const r = sliceRadius + wave;
      const x = cx + Math.cos(angle) * r;
      const y = sliceY + Math.sin(angle) * r * 0.12;

      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();

    ctx.strokeStyle = `rgba(${color[0]},${color[1]},${color[2]},${alpha * 0.85})`;
    ctx.lineWidth = this.thickness * (1 + energy * 2.5);
    ctx.shadowColor = `rgba(${color[0]},${color[1]},${color[2]},${alpha * 1.2})`;
    ctx.shadowBlur = 20 + energy * 45;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
}

// More wave layers for denser, richer look
const WAVE_COUNT = 36;
const waveLayers = [];
for (let i = 0; i < WAVE_COUNT; i++) {
  waveLayers.push(new WaveLayer(i, WAVE_COUNT));
}

// ═══════════════════════════════════════════════════════
//  PARTICLES — more, brighter, larger
// ═══════════════════════════════════════════════════════

class Particle {
  constructor() {
    this.reset();
  }
  reset() {
    const angle = Math.random() * Math.PI * 2;
    const dist = 1.05 + Math.random() * 1.4;
    this.x = Math.cos(angle) * dist;
    this.y = (Math.random() - 0.5) * 2 * dist * 0.6;
    this.z = Math.sin(angle) * dist;
    this.size = 0.8 + Math.random() * 2.5;
    this.speed = 0.1 + Math.random() * 0.35;
    this.alpha = 0.15 + Math.random() * 0.5;
    this.life = Math.random();
  }
  update(dt) {
    this.life += dt * this.speed * 0.1;
    if (this.life > 1) this.reset();
    const angle = Math.atan2(this.z, this.x) + dt * this.speed * 0.3;
    const dist = Math.sqrt(this.x*this.x + this.z*this.z);
    this.x = Math.cos(angle) * dist;
    this.z = Math.sin(angle) * dist;
    this.y += Math.sin(this.life * 6) * dt * 0.02;
  }
  draw(ctx, cx, cy, radius, color) {
    const screenX = cx + this.x * radius;
    const screenY = cy + this.y * radius;
    const depth = (this.z + 1.5) / 3;
    const a = this.alpha * depth * (0.6 + energy * 2);
    const s = this.size * (0.6 + depth * 0.6);

    ctx.beginPath();
    ctx.arc(screenX, screenY, s, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${a})`;
    ctx.shadowColor = `rgba(${color[0]},${color[1]},${color[2]},${a})`;
    ctx.shadowBlur = 12 + energy * 10;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

const particles = Array.from({length: 200}, () => new Particle());

// ═══════════════════════════════════════════════════════
//  MAIN DRAW
// ═══════════════════════════════════════════════════════

function draw(timestamp) {
  requestAnimationFrame(draw);

  const dt = 1/60;
  t += dt;
  const sm = 0.03;

  const tgt = STATES[state];

  // Smooth transitions
  cur.core = lerpA(cur.core, tgt.coreColor, sm);
  cur.glow = lerpA(cur.glow, tgt.glowColor, sm);
  cur.waveAmp = lerp(cur.waveAmp, tgt.waveAmp, sm);
  cur.waveSpeed = lerp(cur.waveSpeed, tgt.waveSpeed, sm);
  cur.spikeAmp = lerp(cur.spikeAmp, tgt.spikeAmp, sm);
  cur.rotSpeed = lerp(cur.rotSpeed, tgt.rotSpeed, sm * 0.5);
  cur.coreGlow = lerp(cur.coreGlow, tgt.coreGlow + energy * 0.4, sm);
  cur.bloomSize = lerp(cur.bloomSize, tgt.bloomSize + energy * 0.6, sm);
  cur.pc = lerpA(cur.pc, tgt.particleColor, sm);
  cur.breathe = lerp(cur.breathe, tgt.breathe, sm);
  cur.ringCount = lerp(cur.ringCount, tgt.ringCount, sm);

  // Energy
  if (state === 'speaking') energyTarget = synthEnergy(t);
  else if (state !== 'listening') energyTarget = 0;
  energy = lerp(energy, energyTarget, energyTarget > energy ? 0.22 : 0.04);

  // Breathing pulse (strongest in listening)
  const breathPulse = Math.sin(t * 3) * cur.breathe;

  // Clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, W, H);

  const cc = cur.core;
  const cg = cur.coreGlow;

  // ── OUTER HALO (very large, subtle) ──
  const haloR = R * (cur.bloomSize + 0.8);
  const haloGrad = ctx.createRadialGradient(CX, CY, R * 0.8, CX, CY, haloR);
  haloGrad.addColorStop(0, `rgba(${cur.glow[0]},${cur.glow[1]},${cur.glow[2]},${0.06 + energy * 0.08 + breathPulse})`);
  haloGrad.addColorStop(0.5, `rgba(${cur.glow[0]},${cur.glow[1]},${cur.glow[2]},${0.02 + energy * 0.03})`);
  haloGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = haloGrad;
  ctx.fillRect(0, 0, W, H);

  // ── AMBIENT GLOW (inner bloom) ──
  const ambR = R * cur.bloomSize;
  const ambGrad = ctx.createRadialGradient(CX, CY, 0, CX, CY, ambR);
  ambGrad.addColorStop(0, `rgba(${cur.glow[0]},${cur.glow[1]},${cur.glow[2]},${0.2 + energy * 0.2 + breathPulse * 2})`);
  ambGrad.addColorStop(0.35, `rgba(${cur.glow[0]},${cur.glow[1]},${cur.glow[2]},${0.08 + energy * 0.1})`);
  ambGrad.addColorStop(0.7, `rgba(${cur.glow[0]},${cur.glow[1]},${cur.glow[2]},${0.02 + energy * 0.04})`);
  ambGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = ambGrad;
  ctx.fillRect(0, 0, W, H);

  // ── CORE ORB (brighter, more vivid) ──
  const coreGrad = ctx.createRadialGradient(
    CX - R * 0.12, CY - R * 0.12, R * 0.02,
    CX, CY, R * 0.95
  );
  coreGrad.addColorStop(0, `rgba(${Math.min(255,cc[0]+120)},${Math.min(255,cc[1]+120)},${Math.min(255,cc[2]+120)},${0.25 + cg * 0.35 + breathPulse * 3})`);
  coreGrad.addColorStop(0.25, `rgba(${cc[0]},${cc[1]},${cc[2]},${0.15 + cg * 0.2})`);
  coreGrad.addColorStop(0.6, `rgba(${Math.floor(cc[0]*0.6)},${Math.floor(cc[1]*0.6)},${Math.floor(cc[2]*0.6)},${0.08 + cg * 0.12})`);
  coreGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = coreGrad;
  ctx.beginPath();
  ctx.arc(CX, CY, R * 1.05, 0, Math.PI * 2);
  ctx.fill();

  // ── ENERGY RINGS (during processing) ──
  if (cur.ringCount > 0.3) {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    const rings = Math.round(cur.ringCount);
    for (let r = 1; r <= rings; r++) {
      const ringPhase = t * (1.5 + r * 0.5);
      const ringExpand = (Math.sin(ringPhase) * 0.5 + 0.5);
      const ringR = R * (1.05 + ringExpand * 0.35 * r);
      const ringAlpha = (1 - ringExpand) * 0.25 * (cur.ringCount / 3);

      ctx.beginPath();
      ctx.arc(CX, CY, ringR, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(${cc[0]},${cc[1]},${cc[2]},${ringAlpha})`;
      ctx.lineWidth = 1.5;
      ctx.shadowColor = `rgba(${cc[0]},${cc[1]},${cc[2]},${ringAlpha * 2})`;
      ctx.shadowBlur = 20;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  // ── WAVE LAYERS ──
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';

  const tgtWC = tgt.waveColors;

  waveLayers.forEach((layer, i) => {
    const colorIdx = i % tgtWC.length;
    const wc = tgtWC[colorIdx];
    const color = [wc[0], wc[1], wc[2]];
    const alpha = wc[3] * (0.6 + energy * 1.8 + breathPulse * 4);

    layer.draw(ctx, t, CX, CY, R, cur.waveAmp + breathPulse, cur.spikeAmp, color, alpha, cur.waveSpeed);
  });

  // ── EQUATORIAL BAND (bright accent ring) ──
  if (energy > 0.005) {
    const bandAlpha = energy * 0.8;
    ctx.beginPath();
    const bandSteps = 300;
    for (let i = 0; i <= bandSteps; i++) {
      const pct = i / bandSteps;
      const angle = pct * Math.PI * 2;
      const wave = Math.sin(angle * 8 + t * 4) * energy * 0.18
                 + Math.sin(angle * 13 - t * 6) * energy * 0.1
                 + Math.sin(angle * 21 + t * 9) * energy * 0.05;
      const r = R * (1 + wave);
      const x = CX + Math.cos(angle) * r;
      const y = CY + Math.sin(angle) * r * 0.08;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.strokeStyle = `rgba(255,255,255,${bandAlpha * 0.5})`;
    ctx.lineWidth = 2.5 + energy * 5;
    ctx.shadowColor = `rgba(${cc[0]},${cc[1]},${cc[2]},${bandAlpha})`;
    ctx.shadowBlur = 35 + energy * 50;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // ── PARTICLES ──
  particles.forEach(p => {
    p.update(dt);
    p.draw(ctx, CX, CY, R, cur.pc);
  });

  ctx.restore();

  // ── EDGE HIGHLIGHT (vivid rim) ──
  ctx.beginPath();
  ctx.arc(CX, CY, R * 0.98, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(${cc[0]},${cc[1]},${cc[2]},${0.08 + energy * 0.12 + breathPulse * 2})`;
  ctx.lineWidth = 1.5;
  ctx.shadowColor = `rgba(${Math.min(255,cc[0]+100)},${Math.min(255,cc[1]+100)},${Math.min(255,cc[2]+100)},${0.5})`;
  ctx.shadowBlur = 15 + energy * 25;
  ctx.stroke();
  ctx.shadowBlur = 0;
}

requestAnimationFrame(draw);

// ═══════════════════════════════════════════════════════
//  UI
// ═══════════════════════════════════════════════════════

const stateLabel = document.getElementById('stateLabel');
const txBox = document.getElementById('transcript');
const labelColors = {
  idle:       'rgba(0,140,255,0.7)',
  listening:  'rgba(0,255,160,0.8)',
  processing: 'rgba(190,60,255,0.8)',
  speaking:   'rgba(255,200,0,0.85)',
};

function setState(s) {
  state = s;
  stateLabel.textContent = s.toUpperCase();
  stateLabel.style.color = labelColors[s];
  txBox.classList.remove('show');
}
window.setState = setState;

function showTx(who, text) {
  document.getElementById('txWho').textContent = who === 'user' ? 'YOU' : '';
  document.getElementById('txWho').style.color = who === 'user' ? '#64FFDA' : '#CE93D8';
  document.getElementById('txText').textContent = text;
  txBox.classList.add('show');
}
function hideTx() { txBox.classList.remove('show'); }
function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

let lTimer = null;
function startLE() {
  let ph = 0;
  lTimer = setInterval(() => {
    ph += 0.14;
    energyTarget = 0.03 + Math.sin(ph)*0.025 + Math.sin(ph*2.7)*0.015 + Math.random()*0.008;
  }, 50);
}
function stopLE() { clearInterval(lTimer); lTimer = null; energyTarget = 0; }

// ═══════════════════════════════════════════════════════
//  DEMO SEQUENCE
// ═══════════════════════════════════════════════════════

async function runDemo() {
  setState('idle'); hideTx(); await wait(2000);

  setState('listening'); startLE(); await wait(500);
  showTx('user', '"What deals should I prioritize this week?"');
  await wait(3000); stopLE();

  setState('processing');
  showTx('system', 'Pulling pipeline data...'); await wait(2500);

  setState('speaking');
  showTx('system', '"3 deals closing Friday. UnifyGTM at $85K is your biggest. Start there."');
  await wait(6500);

  setState('listening'); startLE(); await wait(600);
  showTx('user', '"Coach me on the Bandwidth follow-up"');
  await wait(2800); stopLE();

  setState('processing');
  showTx('system', 'Pulling sequence and notes...'); await wait(2000);

  setState('speaking');
  showTx('system', '"They asked for a case study you haven\'t sent. Lead with that. Listen more this time."');
  await wait(7000);

  setState('idle'); hideTx(); await wait(2500);

  setState('speaking'); await wait(300);
  showTx('system', '"Heads up \u2014 Sarah from Acme just replied to your cold email. Positive sentiment."');
  await wait(5500);

  setState('idle'); await wait(1200); hideTx();
}
window.runDemo = runDemo;

// ═══════════════════════════════════════════════════════
//  LIVE WEBSOCKET (connects to bridge if running)
// ═══════════════════════════════════════════════════════
let _ws = null;
(function tryWS() {
  try {
    const ws = new WebSocket('ws://localhost:3333');
    _ws = ws;
    const map = {
      IDLE:'idle',LISTENING:'listening',PROCESSING:'processing',SPEAKING:'speaking',
      BRIEFING:'speaking',RESEARCHING:'processing',COACHING:'speaking',
      LEARNING:'idle',ERROR:'idle',INTERRUPTED:'listening'
    };
    ws.onmessage = e => {
      const m = JSON.parse(e.data);
      if (m.type==='state') setState(map[m.state]||'idle');
      if (m.type==='snapshot') {
        setState(map[m.state]||'idle');
      }
      if (m.type==='energy') energyTarget = m.rms * 2.5;
      if (m.type==='transcript') showTx(m.speaker, m.text);
    };
    ws.onclose = () => { _ws = null; setTimeout(tryWS, 3000); };
    ws.onerror = () => {};
  } catch(e) {}
})();
</script>
</body>
</html>
